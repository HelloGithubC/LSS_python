#!python -u

import numpy as np 
from LSS_python.mesh import Mesh 
from LSS_python.fftpower import FFTPower
import joblib, os
import argparse, sys

def read_data(filename, weight_key, value_key):
    data = joblib.load(filename)
    if weight_key is not None and weight_key not in data.keys():
        raise ValueError("weight_key not in data")
    if value_key is not None and value_key not in data.keys():
        raise ValueError("value_key not in data")
    if "Pos" not in data.keys():
        if "X" in data.keys():
            data["Pos"] = np.stack([data["X"], data["Y"], data["Z"]], axis=1)
        else:
            raise ValueError("Pos not in data and X, Y, Z not in data")
    return data
    
    
def split_filename(filename):
    file_dir, file_name = os.path.split(filename)
    if file_dir == "":
        pass
    else:
        file_dir += "/"
    file_name, file_ext = os.path.splitext(file_name)
    return file_dir, file_name, file_ext
        
    
parser = argparse.ArgumentParser(
    prog="cal_fftpower_box", usage="To cal fftpower with LSS_python for simulation box"
)

parser.add_argument("data_filename", help="Only support joblib file with a dict", type=str)
parser.add_argument("BoxSize", type=float, help="If <=0, will be calculated from data")
parser.add_argument("Nmesh", type=int)
parser.add_argument("nthreads", type=int)

parser.add_argument("--weight_key", "-wei", type=str, default=None, help="Set it to enable weight")
parser.add_argument("--value_key", "-val", type=str, default=None, help="Set it to enable value")
parser.add_argument("--is_norm", "-norm", action="store_true", help="Set it to enable norm in to_mesh")

parser.add_argument("-kmin", type=float, default=0.1, help="Default 0.1")
parser.add_argument("-kmax", type=float, default=1.0, help="Default 1.0")
parser.add_argument("-dk", type=float, default=0.1, help="Default 0.1")
parser.add_argument("-Nmu", type=int, default=30, help="Default 30")
parser.add_argument("-mode", type=str, default="1d", help="Support '1d' and '2d'. Default '1d'")

parser.add_argument("--fftpower_filename", "-fftpower", help="The fftpower filename. Default fftpower-${data_filename}-Nmesh${Nmesh}-k${kmin}to${kmax}_dk${dk}_Nmu${Nmu}(Or _1d if mode is '1d' and '.' will be replace with dot)", default=None)
parser.add_argument("--mesh_dir", "-mesh", help="The mesh dir. Default mesh-${data_filename}-BoxSize{boxsize}_Nmesh${Nmesh}", default=None)

parser.add_argument("--only_run_mesh", "-only_mesh", action="store_true")
parser.add_argument("-force", "-f", action="store_true", help="Force to run fftpower")
parser.add_argument("--force_mesh", "-forcem", action="store_true", help="Force to run mesh")

parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output.")

if len(sys.argv) == 1:
    parser.print_help()
    exit(0)

argv = parser.parse_args()

data_filename = argv.data_filename
data_dir, data_name, data_ext = split_filename(data_filename)

boxsize = argv.BoxSize
Nmesh = argv.Nmesh
nthreads = argv.nthreads

weight_key = argv.weight_key
if weight_key is not None:
    use_weight_key = True 
else:
    use_weight_key = False
value_key = argv.value_key
if value_key is not None:
    use_value_key = True
else:
    use_value_key = False
is_norm = argv.is_norm

kmin = argv.kmin
kmin_str = f"{kmin:.1f}".replace(".", "dot")
kmax = argv.kmax
kmax_str = f"{kmax:.1f}".replace(".", "dot")
dk = argv.dk
dk_str = f"{dk:.2f}".replace(".", "dot")
Nmu = argv.Nmu
mode = argv.mode
if mode == "1d":
    mode_str = "1d"
else:
    mode_str = f"Nmu{Nmu:d}"

fftpower_filename = argv.fftpower_filename
if fftpower_filename is None:
    fftpower_filename = f"fftpower-{data_name}-Nmesh${Nmesh:d}-k{kmin_str}to{kmax_str}_dk{dk_str}_{mode_str}"
mesh_dir = argv.mesh_dir
if mesh_dir is None:
    mesh_dir = f"mesh-{data_name}-BoxSize{boxsize:.0f}_Nmesh{Nmesh:d}"

data = read_data(data_filename, weight_key, value_key)
mesh = Mesh(Nmesh, boxsize)
if use_weight_key:
    weights = data[weight_key]
else:
    weights = None
if use_value_key:
    values = data[value_key]
else:
    values = None

only_run_mesh = argv.only_run_mesh
force = argv.force
force_mesh = argv.force_mesh
verbose = argv.verbose

if not os.path.exists(mesh_dir) or force_mesh:
    if verbose:
        print("Now running mesh...")
        print(f"Number of particles is {data['Pos'].shape[0]:d}; Boxsize is {boxsize:.0f}; Nmesh is {Nmesh:d}.")
        print(f"Use resampler CIC; Use weights: {use_weight_key}; Use values: {use_value_key}; Use norm: {is_norm}")
        print(f"Use nthreads: {nthreads:d}")
    mesh.to_mesh(data["Pos"], resampler="CIC", weights=weights, values=values, nthreads=nthreads, is_norm=is_norm, c_api=True)
    if verbose:
        print(f"Mesh created. Now saving mesh to {mesh_dir}")
    mesh.save(mesh_dir, mode="all")
    if verbose:
        print("Mesh saved.")
elif only_run_mesh:
    print("Mesh already exists. Skip.")
    exit(0)
else:
    mesh = Mesh.load(mesh_dir, only_complex=True)

if not only_run_mesh:
    if not os.path.exists(fftpower_filename) or force:
        fftpower = FFTPower(Nmesh, boxsize)
        if verbose:
            print("Now running fftpower...")
            print(f"kmin is {kmin:.1f}; kmax is {kmax:.1f}; dk is {dk:.2f}; Nmu is {Nmu:d}; mode is {mode}")
            print(f"Use nthreads: {nthreads:d}")
        power = fftpower.cal_ps_from_mesh(mesh, kmin, kmax, dk, Nmu, mode=mode, nthreads=nthreads, c_api=True, compensated=True)
        fftpower.save(fftpower_filename)
        if verbose:
            print(f"fftpower saved to {fftpower_filename}")